import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
    Table, Spin, Alert, Empty, Pagination, Button, Input, Modal, Form, Select, InputNumber, DatePicker, Checkbox, Space, message, Upload, Tooltip, Typography, Dropdown, Menu
} from 'antd';
import { ColumnsType, TablePaginationConfig, SorterResult, SortOrder, Key } from 'antd/es/table/interface';
import * as api from '../../api';
import {
    FilterOutlined, SearchOutlined, UploadOutlined, GroupOutlined, ClearOutlined, DownOutlined, PlusOutlined, DeleteOutlined, InboxOutlined
} from '@ant-design/icons';
import { ApiColumnSchema, NewColumnPayload } from '../../api/types';
import { UploadFile, UploadProps } from 'antd';
import type { RcFile } from 'antd/es/upload/interface'; 
import dayjs from 'dayjs';
import { debounce } from 'lodash';


interface FetchParams {
    page: number;
    limit: number;
    filters?: FilterCondition[];
    group_by?: string[];
}

const { confirm } = Modal;
const { Option } = Select;
const { Title, Text } = Typography;
const { Dragger } = Upload;

interface DataGridProps {
    dbId: number | null;
    tableName: string | null;
}

type EditingRowData = Record<string, any> | null;


interface SortConfig {
    field: Key | null;
    order: SortOrder | null;
}


interface FilterCondition {
    id: number; 
    column?: string;
    operator?: string;
    value?: any;
    logicalOperator?: 'AND' | 'OR'; 
}


const SUPPORTED_COLUMN_TYPES = [
    'TEXT', 'VARCHAR',
    'INTEGER', 'INT', 'BIGINT', 'SMALLINT', 'SERIAL', 'BIGSERIAL', 
    'NUMERIC', 'DECIMAL', 'FLOAT', 'REAL', 'DOUBLE PRECISION',
    'BOOLEAN', 'BOOL',
    'DATE', 'TIMESTAMP', 'TIMESTAMP WITH TIME ZONE', 'DATETIME', 
    'JSON', 'JSONB', 'UUID' 
];


const FILTER_OPERATORS = [
    { label: 'Equals (=)', value: '=' },
    { label: 'Not Equals (!=)', value: '!=' },
    { label: 'Greater Than (>)', value: '>' },
    { label: 'Greater Than or Equals (>=)', value: '>=' },
    { label: 'Less Than (<)', value: '<' },
    { label: 'Less Than or Equals (<=)', value: '<=' },
    { label: 'Contains (LIKE)', value: 'LIKE' },
    { label: 'Does Not Contain (NOT LIKE)', value: 'NOT LIKE' },
    { label: 'Is Null', value: 'IS NULL' },
    { label: 'Is Not Null', value: 'IS NOT NULL' },
];


const ACCEPTED_UPLOAD_TYPES = [
    '.csv',
    'text/csv', 
    'application/vnd.ms-excel', 
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 
    
];
const ACCEPTED_UPLOAD_EXTENSIONS_STRING = ".csv"; 

const DataGrid: React.FC<DataGridProps> = ({ dbId, tableName }) => {
    const [schema, setSchema] = useState<ApiColumnSchema[]>([]);
    const [data, setData] = useState<any[]>([]); 
    const [totalRows, setTotalRows] = useState<number>(0);
    const [currentPage, setCurrentPage] = useState<number>(1);
    const [pageSize, setPageSize] = useState<number>(20);
    const [loadingSchema, setLoadingSchema] = useState<boolean>(false);
    const [loadingData, setLoadingData] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const [primaryKeyName, setPrimaryKeyName] = useState<string | null>(null);
    const [isPkAutoGenerated, setIsPkAutoGenerated] = useState<boolean>(false); 

    
    const [editingKey, setEditingKey] = useState<string>('');
    const [editingRowData, setEditingRowData] = useState<EditingRowData>(null);

    
    const [isAddModalVisible, setIsAddModalVisible] = useState<boolean>(false);
    const [addForm] = Form.useForm();
    const [confirmLoadingAdd, setConfirmLoadingAdd] = useState<boolean>(false);

    
    const [isAddColModalVisible, setIsAddColModalVisible] = useState<boolean>(false);
    const [addColForm] = Form.useForm();
    const [confirmLoadingAddCol, setConfirmLoadingAddCol] = useState<boolean>(false);

    
    const [searchQuery, setSearchQuery] = useState<string>('');

    
    const [sortConfig, setSortConfig] = useState<SortConfig>({ field: null, order: null });

    const [refetchTrigger, setRefetchTrigger] = useState<number>(0); 

    
    const [filterConfig, setFilterConfig] = useState<FilterCondition[]>([]);
    const [isFilterModalVisible, setIsFilterModalVisible] = useState(false);
    const [filterForm] = Form.useForm(); 

    
    const [groupingColumn, setGroupingColumn] = useState<string[]>([]);
    const [IsGroupModalVisible, setIsGroupModalVisible] = useState(false);

    
    const [uploading, setUploading] = useState(false);
    const [isUploadModalVisible, setIsUploadModalVisible] = useState(false);
    
    const [databaseName, setDatabaseName] = useState<string | null>(null);
    const [loadingDbName, setLoadingDbName] = useState<boolean>(false);
    const [dbNameError, setDbNameError] = useState<string | null>(null);

    
    const debouncedSearch = useCallback(
        debounce((query: string) => {
            setSearchQuery(query);
            
        }, 300), 
        []
    );

    
    const generateRowKey = useCallback((row: any, index: number): string => {
        if (primaryKeyName && row[primaryKeyName] !== undefined && row[primaryKeyName] !== null) {
            
            return `row-${dbId}-${tableName}-pk-${row[primaryKeyName]}`;
        }
        
        return `row-${dbId}-${tableName}-page-${currentPage}-index-${index}`;
   }, [dbId, tableName, primaryKeyName, currentPage]);


    
    useEffect(() => {
        if (!dbId || !tableName) {
            
            setSchema([]); setData([]); setError(null); setPrimaryKeyName(null); setIsPkAutoGenerated(false);
            setEditingKey(''); setEditingRowData(null); setIsAddModalVisible(false); setIsAddColModalVisible(false);
            addForm.resetFields(); addColForm.resetFields();
            setCurrentPage(1); setPageSize(20); setTotalRows(0); 
            setSearchQuery(''); 
            setSortConfig({ field: null, order: null }); 
            setFilterConfig([]); filterForm.resetFields(); setGroupingColumn([]); 
            setIsUploadModalVisible(false); 
            return;
        }
        
        setLoadingSchema(true); setError(null); setSchema([]); setData([]);
        setCurrentPage(1); setPageSize(20); setTotalRows(0); 
        setPrimaryKeyName(null); setIsPkAutoGenerated(false); setEditingKey('');
        setEditingRowData(null); setIsAddModalVisible(false); setIsAddColModalVisible(false);
        addForm.resetFields(); addColForm.resetFields();
        setSearchQuery(''); 
        setSortConfig({ field: null, order: null }); 
        setFilterConfig([]); filterForm.resetFields(); setGroupingColumn([]); 
        setIsUploadModalVisible(false); 
        setRefetchTrigger(0); 

        console.log(`DataGrid: Fetching schema for DB: ${dbId}, Table: ${tableName}`);
        api.fetchSchema(dbId, tableName)
            .then((fetchedSchema) => {
                console.log("DataGrid: Schema fetched:", fetchedSchema);
                if (!Array.isArray(fetchedSchema)) {
                    throw new Error("Invalid schema format received.");
                }
                setSchema(fetchedSchema);
                const pk = fetchedSchema.find((col) => col.isPrimaryKey);
                setPrimaryKeyName(pk ? pk.name : null);
                setIsPkAutoGenerated(pk ? Boolean(pk.isAutoGenerated) : false); 
                if (!pk) {
                    console.warn(`DataGrid: Table "${tableName}" in DB ${dbId} has no primary key. Edit/Delete operations might fail or be disabled.`);
                    message.warning(`Table "${tableName}" has no primary key identified. Edit/Delete operations may be disabled or unstable.`, 5);
                } else {
                    console.info(`DataGrid: Primary key for DB ${dbId}, table "${tableName}" is "${pk.name}". Auto-generated: ${isPkAutoGenerated}`);
                }
            })
            .catch((err) => {
                console.error(`DataGrid: Schema fetch error for DB ${dbId}, Table ${tableName}:`, err);
                setError(`Failed to load schema: ${err.message}`);
                setPrimaryKeyName(null); setIsPkAutoGenerated(false); setSchema([]);
            })
            .finally(() => setLoadingSchema(false));

    }, [dbId, tableName, addForm, addColForm, filterForm]); 


    
    useEffect(() => {
        
        if (!dbId || !tableName || loadingSchema || (!loadingSchema && schema.length === 0 && !error)) {
             if (!loadingSchema && schema.length === 0 && !error && dbId && tableName) {
                setData([]);
                setTotalRows(0);
             }
            return;
        };

        
        if (editingKey) {
            console.log("Data fetch skipped: Row editing in progress.");
            return;
        }

        setLoadingData(true);
        console.log(`DataGrid: Fetching data for DB: ${dbId}, Table: ${tableName}, Page: ${currentPage}, Size: ${pageSize}, Filters: ${filterConfig.length}, GroupBy: ${groupingColumn}`);

        
        const fetchParams: FetchParams = {
            page: currentPage,
            limit: pageSize,
            
            ...(filterConfig.length > 0 && { filters: filterConfig }),
            ...(groupingColumn.length> 0  && { group_by: groupingColumn }),
        };

        
        api.fetchData(dbId, tableName, fetchParams)
            .then((response) => {
                console.log("table:", tableName);
                console.log("DataGrid: Data fetched (raw):", response);
                if (!response || !Array.isArray(response.data) || typeof response.total !== 'number') {
                    throw new Error("Invalid data format received from server.");
                }
                
                const processedData = response.data.map((row, index) => ({
                     ...row,
                     key: generateRowKey(row, index)
                }));
                console.log("DataGrid: Data processed for state:", processedData);
                setData(processedData); 
                setTotalRows(response.total);
                
                if (error?.startsWith("Failed to load data")) setError(null);
            })
            .catch((err) => {
                console.error(`DataGrid: Data fetch error for DB ${dbId}, Table ${tableName}:`, err);
                setError(`Failed to load data: ${err.message}`);
                setData([]); setTotalRows(0); 
            })
            .finally(() => setLoadingData(false));

    
    }, [
        dbId,
        tableName,
        currentPage,
        pageSize,
        filterConfig,   
        groupingColumn,
        loadingSchema,  
        schema,         
        error,          
        editingKey,     
        refetchTrigger, 
        generateRowKey  
    ]);

    useEffect(() => {
        
        if (dbId === null || dbId === undefined || isNaN(dbId)) {
            setDatabaseName('Invalid DB ID');
            setLoadingDbName(false);
            setDbNameError(null);
            return;
        }
    
        let isMounted = true; 
        setLoadingDbName(true);
        setDbNameError(null);
        setDatabaseName(null); 
    
        const fetchName = async () => {
            console.log(`DataGrid Title: Attempting to fetch name for dbId: ${dbId}`);
            try {
                console.log(`DataGrid Title: Fetching name with effective dbId: ${dbId}`); 
                const name = await api.getDatabaseName(dbId);
                if (isMounted) {
                    console.log(`DataGrid Title: Successfully fetched name: ${name}`);
                    setDatabaseName(name);
                }
            } catch (error: any) {
                console.error("DataGrid Title: Error fetching database name:", error);
                if (isMounted) {
                    setDatabaseName('Error'); 
                    setDbNameError(error instanceof Error ? error.message : 'Failed to load DB name');
                }
            } finally {
                if (isMounted) {
                    setLoadingDbName(false);
                }
            }
        };
    
        fetchName();
    
        
        return () => {
            isMounted = false;
        };
    }, [dbId]);


    
    const displayedData = useMemo(() => {
        let filteredData = [...data]; 

        
        if (searchQuery && schema.length > 0) { 
            const lowerCaseQuery = searchQuery.toLowerCase();
            filteredData = filteredData.filter(row =>
                schema.some(col => {
                    const value = row[col.name];
                    
                    return value !== null && value !== undefined && String(value).toLowerCase().includes(lowerCaseQuery);
                })
            );
        }

        
        if (sortConfig.field && sortConfig.order && schema.length > 0) { 
            const { field, order } = sortConfig;
            const sortField = String(field); 
            filteredData.sort((a, b) => {
                const valueA = a[sortField];
                const valueB = b[sortField];

                
                let comparison = 0;
                if (valueA === null || valueA === undefined) comparison = (valueB === null || valueB === undefined) ? 0 : -1; 
                else if (valueB === null || valueB === undefined) comparison = 1;
                else if (valueA < valueB) comparison = -1;
                else if (valueA > valueB) comparison = 1;

                return order === 'descend' ? comparison * -1 : comparison;
            });
        }

        return filteredData;
    }, [data, searchQuery, sortConfig, schema]); 

    const handleTableChange = (
        pagination: TablePaginationConfig, 
        filters: Record<string, (Key | boolean)[] | null>, 
        sorter: SorterResult<any> | SorterResult<any>[] 
        ) => {
            
            if (editingKey) {
                message.warning('Please save or cancel edit first.');
                return;
            }
        console.log("DataGrid: Table change event (sorter for frontend):", sorter);

        
        const currentSorter = Array.isArray(sorter) ? sorter[0] : sorter;

        let newSortConfig: SortConfig = { field: null, order: null };

        if (currentSorter && currentSorter.columnKey && currentSorter.order) {
            
            newSortConfig = { field: currentSorter.columnKey, order: currentSorter.order };
        }

        
        if (newSortConfig.field !== sortConfig.field || newSortConfig.order !== sortConfig.order) {
            console.log("DataGrid: Updating frontend sort config:", newSortConfig);
            setSortConfig(newSortConfig);
            
        }
    };

    
    const renderFormInput = (col: ApiColumnSchema, isFilterInput: boolean = false) => {
        const numericTypesLC = ['numeric', 'integer', 'int', 'bigint', 'smallint', 'float', 'double', 'decimal', 'real', 'serial', 'bigserial'];
        const dateTypesLC = ['date', 'timestamp', 'datetime', 'timestamptz', 'timestamp with time zone'];
        const booleanTypesLC = ['boolean', 'bool'];
        
        const colTypeLC = col.type.toLowerCase().split('(')[0].split(' ')[0];

        if (numericTypesLC.includes(colTypeLC)) {
            return <InputNumber style={{ width: '100%' }} placeholder={"Enter number"} />;
        } else if (dateTypesLC.includes(colTypeLC)) {
            const showTime = colTypeLC.includes('timestamp') || colTypeLC.includes('datetime');
            return <DatePicker style={{ width: '100%' }} showTime={showTime} placeholder={`Select date${showTime ? '/time' : ''}`} format={showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD"} />;
        } else if (booleanTypesLC.includes(colTypeLC)) {
            
            
            return (
                <Select style={{ width: '100%' }} placeholder="Select True/False/Null" allowClear={isFilterInput} >
                    <Option value={true}>True</Option>
                    <Option value={false}>False</Option>
                    {isFilterInput && <Option value={null}>Null</Option>} {/* Only show Null option in filter context */}
                </Select>
            );
        }
        
        else {
            return <Input placeholder={"Enter text"} />;
        }
    };

    
    const renderFilterValueInput = (columnIndex?: number) => {
        if (columnIndex === undefined) return <Input disabled placeholder="Select column first" />;

        const field = filterForm.getFieldValue(['conditions', columnIndex, 'column']);
        const operator = filterForm.getFieldValue(['conditions', columnIndex, 'operator']);
        const selectedColumn = schema.find(col => col.name === field);

        if (operator === 'IS NULL' || operator === 'IS NOT NULL') {
            return <Input disabled placeholder="No value needed" style={{ width: 200 }}/>;
        }

        if (!selectedColumn) return <Input disabled placeholder="Select column first" style={{ width: 200 }}/>;

        
        const InputComponent = renderFormInput(selectedColumn, true);
        
        return React.cloneElement(InputComponent, { style: { ...InputComponent.props.style, width: 200 } });
    };

    const preparePayload = (
        inputValues: Record<string, any>,
        schemaRef: ApiColumnSchema[],
        isInsert: boolean = false,
        pkName: string | null,
        pkIsAutoGenerated: boolean 
    ): Record<string, any> | null => {
        const payload: Record<string, any> = {};
        let parsingError = false;
        let errors: string[] = [];

        schemaRef.forEach(col => {
            if ((isInsert && col.name === pkName && pkIsAutoGenerated) || (!isInsert && col.name === pkName)) {
                console.log(`Payload Prep: Skipping PK "${col.name}" (isInsert: ${isInsert}, isAutoGenerated: ${pkIsAutoGenerated})`);
               return;
            }
            if (inputValues.hasOwnProperty(col.name)) {
                const rawValue = inputValues[col.name];
                 
                const colTypeLC = col.type.toLowerCase().split('(')[0].split(' ')[0];
                const numericTypesLC = ['numeric', 'integer', 'int', 'bigint', 'smallint', 'float', 'double', 'decimal', 'real'];
                const dateTypesLC = ['date', 'timestamp', 'datetime', 'timestamptz']; 
                const booleanTypesLC = ['boolean', 'bool'];

                if (rawValue === '' || rawValue === null || rawValue === undefined) {
                    if (!col.isNullable && isInsert && !(col.isPrimaryKey && pkIsAutoGenerated)) {
                        errors.push(`Column "${col.name}" cannot be empty (required).`);
                        parsingError = true;
                    } else if (!col.isNullable && !isInsert) {

                        console.warn(`Payload Prep: Setting non-nullable column "${col.name}" to null during update.`);
                        payload[col.name] = null;
                    }
                    else {
                         payload[col.name] = null; 
                    }
                }
                
                else if (numericTypesLC.includes(colTypeLC)) {
                    
                    const numValue = Number(String(rawValue).replace(/,/g, '')); 
                    if (isNaN(numValue)) {
                        errors.push(`Invalid number format for "${col.name}": ${rawValue}`);
                        parsingError = true;
                    } else { payload[col.name] = numValue; }
                }
                
                else if (dateTypesLC.includes(colTypeLC)) {
                    if (dayjs.isDayjs(rawValue)) { 
                        if (rawValue.isValid()) {
                             payload[col.name] = rawValue.toISOString(); 
                        } else {
                            errors.push(`Invalid date value provided for "${col.name}".`);
                            parsingError = true;
                        }
                    } else if (typeof rawValue === 'string') { 
                        const parsedDate = dayjs(rawValue);
                        if (parsedDate.isValid()) {
                            payload[col.name] = parsedDate.toISOString();
                        } else {
                            errors.push(`Invalid date string format for "${col.name}": ${rawValue}`);
                            parsingError = true;
                        }
                    } else if (rawValue instanceof Date) { 
                        payload[col.name] = rawValue.toISOString();
                    } else {
                        errors.push(`Invalid date input type for "${col.name}"`);
                        parsingError = true;
                    }
                }
                
                else if (booleanTypesLC.includes(colTypeLC)) {
                    if (rawValue === true || String(rawValue).toLowerCase() === 'true') {
                        payload[col.name] = true;
                    } else if (rawValue === false || String(rawValue).toLowerCase() === 'false') {
                        payload[col.name] = false;
                    } else {
                        
                        if (!col.isNullable && isInsert && !(col.isPrimaryKey && pkIsAutoGenerated)) {
                            errors.push(`Boolean column "${col.name}" cannot be empty (required).`);
                            parsingError = true;
                        } else {
                            payload[col.name] = null; 
                            if (!col.isNullable) {
                                console.warn(`Payload Prep: Setting non-nullable boolean column "${col.name}" to null during update.`);
                            }
                        }
                    }
                }
                
                else {
                     payload[col.name] = String(rawValue);
                }
            } else if (isInsert && !col.isNullable && !(col.isPrimaryKey && pkIsAutoGenerated)) {
                
                errors.push(`Column "${col.name}" is required.`);
                parsingError = true;
            }
        });

        if (parsingError) {
            message.error(`Please fix validation errors: ${errors.join('; ')}`);
            console.error("DataGrid: Payload preparation failed.", errors, inputValues);
            return null;
        }
        console.log("DataGrid: Prepared Payload:", payload);
        return payload;
    };


    
    const showAddModal = () => { addForm.resetFields(); setIsAddModalVisible(true); };
    const handleAddCancel = () => { setIsAddModalVisible(false); };
    const handleAddOk = async () => {
        if (!dbId || !tableName) return;
        try {
            setConfirmLoadingAdd(true);
            const values = await addForm.validateFields();
            const payload = preparePayload(values, schema, true, primaryKeyName, isPkAutoGenerated);
            if (!payload) { setConfirmLoadingAdd(false); return; }

            console.log("DataGrid: ðŸ“¦ Sending Create Payload:", payload);
            await api.createRecord(dbId, tableName, payload);
            message.success('Record added successfully!');
            setIsAddModalVisible(false);

            const isViewModified = !!sortConfig.field || !!searchQuery || filterConfig.length > 0 || groupingColumn.length > 0;
            const isOnPage1 = currentPage === 1;

            if (!isOnPage1 || (isOnPage1 && isViewModified)) {
                console.log(`Setting current page to 1 after add. Reason: ${!isOnPage1 ? 'Not on page 1' : 'On page 1 with view modifications'}`);
                if (isOnPage1) {
                    setRefetchTrigger(c => c + 1);
                } else {
                    setCurrentPage(1);
                }
            } else {
                console.log("On page 1 without view modifications. Forcing refetch of current page via trigger.");
                setRefetchTrigger(c => c + 1);
            }

        } catch (errorInfo: any) {
            console.error('DataGrid: Add Row Failed:', errorInfo);
            const errorMsg = errorInfo?.response?.data?.error
                            || errorInfo?.response?.data?.message
                            || (errorInfo instanceof Error ? errorInfo.message : null)
                            || 'Unknown error';
            if (errorInfo.errorFields) { message.error('Validation failed. Check the form fields.'); }
            else { message.error(`Failed to add record: ${errorMsg}`); }
        } finally {
            setConfirmLoadingAdd(false);
        }
    };


    
    const isEditing = (record: any) => record.key === editingKey;

    const handleEdit = (record: any) => {
        if (!primaryKeyName && record.key.includes('-pk-')) {
             
             try {
                 const parts = record.key.split('-pk-');
                 const pkValue = parts[1];
                 const inferredPkName = Object.keys(record).find(k => String(record[k]) === pkValue && k !== 'key');
                 if (inferredPkName) {
                      console.warn(`PK name was null, inferring "${inferredPkName}" from row key.`);
                      
                      message.warning(`Primary Key was not identified in schema, attempting edit based on inferred key "${inferredPkName}". Use with caution.`);
                 } else {
                      message.error("Cannot edit: Primary Key missing and could not be inferred from row key.");
                      return;
                 }
             } catch {
                 message.error("Cannot edit: Primary Key missing and could not be inferred from row key.");
                 return;
             }
        } else if (!primaryKeyName) {
            message.error("Cannot edit: Primary Key information missing.");
             return;
        }

        console.log("DataGrid: Editing record:", record);
        const initialEditData = { ...record };

        
        schema.forEach(col => {
            const dateTypesLC = ['date', 'timestamp', 'datetime', 'timestamptz', 'timestamp with time zone'];
             
            const colTypeLC = col.type.toLowerCase().split('(')[0].split(' ')[0];

            if (dateTypesLC.includes(colTypeLC) && initialEditData[col.name]) {
                const parsedDate = dayjs(initialEditData[col.name]); 
                if (parsedDate.isValid()) {
                    initialEditData[col.name] = parsedDate; 
                } else {
                    console.warn(`Could not parse date string "${initialEditData[col.name]}" for column "${col.name}" during edit start.`);
                    initialEditData[col.name] = null; 
                }
            }
        });

        setEditingRowData(initialEditData);
        setEditingKey(record.key);
    };

    const handleCancel = () => { setEditingKey(''); setEditingRowData(null); };

    const handleSave = async () => {
        if (!dbId || !tableName || !editingKey || !editingRowData) {
            console.error("Save aborted: Missing dbId, tableName, editingKey, or editingRowData.");
            return;
        }
        const originalRecord = data.find(item => item.key === editingKey);

        if (!originalRecord) {
             message.error("Cannot save row: Original record not found in current page data. Please Cancel and try again.");
             console.error("Original record with key", editingKey, "not found in data:", data);
             return;
         }
        const currentPkName = primaryKeyName || Object.keys(originalRecord).find(k => k !== 'key' && `row-${dbId}-${tableName}-pk-${originalRecord[k]}` === editingKey);

         if (!currentPkName) {
             message.error("Cannot save row: Primary key name could not be determined.");
             return;
         }
         const pkValue = originalRecord[currentPkName];


        if (pkValue === undefined || pkValue === null) {
            message.error(`Cannot save row: Primary key ("${currentPkName}") value is missing in original data.`);
            return;
        }

        const dataToSave = { ...editingRowData };
        delete dataToSave.key;
        const payload = preparePayload(dataToSave, schema, false, currentPkName, isPkAutoGenerated);
        if (!payload) { return; }
        let changed = false;
        for (const key in payload) {
            if (payload.hasOwnProperty(key)) {
                const originalValue = originalRecord[key];
                const newValue = payload[key];
                const col = schema.find(c => c.name === key);
                const colTypeLC = col?.type.toLowerCase().split('(')[0].split(' ')[0] || '';
                const dateTypesLC = ['date', 'timestamp', 'datetime', 'timestamptz'];

                if (dateTypesLC.includes(colTypeLC)) {
                    const originalDateStr = originalValue ? dayjs(originalValue).toISOString() : null;
                    const newDateStr = newValue ? String(newValue) : null;
                    if (originalDateStr !== newDateStr) {
                        console.log(`Change detected (Date): ${key}: ${originalDateStr} -> ${newDateStr}`);
                        changed = true; break;
                    }
                } else {
                    if ((originalValue === null || originalValue === undefined) && (newValue === null || newValue === undefined)) {
                        continue;
                    }
                    if (String(originalValue) !== String(newValue)) {
                         console.log(`Change detected (Other): ${key}: ${originalValue} (Type: ${typeof originalValue}) -> ${newValue} (Type: ${typeof newValue})`);
                        changed = true; break;
                    }
                }
            }
        }

        if (!changed && Object.keys(payload).length > 0) {
             message.info("No changes detected to save.");
             handleCancel();
             return;
         } else if (Object.keys(payload).length === 0 && !changed) {
             message.info("No editable fields modified.");
             handleCancel();
             return;
         }

        const messageKey = `update-${editingKey}`;
        try {
             setLoadingData(true); 
             message.loading({ content: "Saving...", key: messageKey, duration: 0 });
            console.log("DataGrid: ðŸ“¦ Sending Update Payload:", payload, `for PK ${currentPkName}=${pkValue}`);
            const updatedRowFromServer = await api.updateRecord(dbId, tableName, pkValue, payload);
            console.log("DataGrid: Received updated row from server:", updatedRowFromServer);

            setData((prevData) => {
                const index = prevData.findIndex(item => item.key === editingKey);
                if (index === -1) {
                    console.warn("Edited record key not found in data after save, returning previous data.");
                    return prevData;
                }
                const newData = [...prevData];
                 
                newData[index] = { ...originalRecord, ...updatedRowFromServer, key: editingKey };
                console.log("DataGrid: Updated local data state with server response:", newData[index]);
                return newData;
            });

            message.success({ content: 'Record updated successfully!', key: messageKey, duration: 2 });
            handleCancel(); 

        } catch (err: any) {
            console.error('DataGrid: Update Row Failed:', err);
            const errorMsg = err.response?.data?.error || err.response?.data?.message || err.message || 'Unknown error';
            message.error({ content: `Failed to update record: ${errorMsg}`, key: messageKey, duration: 4 });
        } finally {
             setLoadingData(false);
             message.destroy(messageKey);
        }
    };

    const handleEditingInputChange = (value: any, dataIndex: string ) => {
        if (!editingRowData) return;
        console.log(`Input change: ${dataIndex} =`, value);
        let processedValue = value;
        if (value && value.target) {
            processedValue = value.target.type === 'checkbox' ? value.target.checked : value.target.value;
        }
         else if (dayjs.isDayjs(value)) {
              processedValue = value; 
         }
         else if (value === null) {
             const colSchema = schema.find(col => col.name === dataIndex);
             const dateTypesLC = ['date', 'timestamp', 'datetime', 'timestamptz', 'timestamp with time zone'];
             const colTypeLC = colSchema?.type.toLowerCase().split('(')[0].split(' ')[0];
             if (colSchema && dateTypesLC.includes(colTypeLC || '')) {
                 processedValue = null; 
             }
         }


        console.log(`Processed input change: ${dataIndex} =`, processedValue);
        setEditingRowData(prev => ({ ...prev, [dataIndex]: processedValue }));
    };


    
    const handleDelete = (recordToDelete: any) => {
         if (!dbId || !tableName) {
             message.error("Cannot delete row: Database or Table context missing.");
             return;
         }
         const currentPkName = primaryKeyName || Object.keys(recordToDelete).find(k => k !== 'key' && `row-${dbId}-${tableName}-pk-${recordToDelete[k]}` === recordToDelete.key);

         if (!currentPkName) {
             message.error("Cannot delete row: Primary key name could not be determined.");
             return;
         }
         const primaryKeyValue = recordToDelete[currentPkName];

          if (primaryKeyValue === undefined || primaryKeyValue === null) {
             message.error(`Cannot delete row: Primary key ("${currentPkName}") value is missing.`);
             return;
         }
         const displayValue = String(primaryKeyValue);

        confirm({
            title: 'Are you sure delete this record?',
            content: `Record with ${currentPkName}=${displayValue} will be permanently deleted.`,
            okText: 'Yes, Delete', okType: 'danger', cancelText: 'No', maskClosable: false,
            onOk: async () => {
                const messageKey = `delete-${recordToDelete.key}`;
                let operationLoading = false;
                try {
                    setLoadingData(true);
                    operationLoading = true;
                    message.loading({ content: `Deleting record...`, key: messageKey, duration: 0 });

                    await api.deleteRecord(dbId, tableName, primaryKeyValue);

                    message.success({ content: 'Record deleted successfully!', key: messageKey, duration: 2 });
                    if (editingKey === recordToDelete.key) { handleCancel(); } 
                    setError(null);
                    const isLastItemOnPage = data.length === 1 && totalRows > 1; 
                    const pageToFetch = (isLastItemOnPage && currentPage > 1) ? currentPage - 1 : currentPage;

                    if (pageToFetch !== currentPage) {
                        console.log(`Delete caused page change to: ${pageToFetch}`);
                        setCurrentPage(pageToFetch);
                        operationLoading = false;
                    } else {
                        console.log("Forcing refetch on current page after delete via trigger.");
                        setRefetchTrigger(c => c + 1);
                        operationLoading = false;
                    }
                } catch (err: any) {
                    message.error({ content: `Failed to delete record: ${err.message || 'Unknown error'}`, key: messageKey, duration: 4 });
                    console.error('DataGrid: Delete Row Failed:', err);
                    setError(`Failed to delete record: ${err.message}`);
                    if (operationLoading) {
                        setLoadingData(false);
                    }
                } finally {
                     message.destroy(messageKey);
                }
            },
            onCancel: () => {
                console.log('Delete cancelled');
            },
        });
    };


    
    const showAddColModal = () => { addColForm.resetFields(); setIsAddColModalVisible(true); };
    const handleAddColCancel = () => { setIsAddColModalVisible(false); };
    const handleAddColOk = async () => {
        if (!dbId || !tableName) return;
        try {
            setConfirmLoadingAddCol(true);
            const values = await addColForm.validateFields();
            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(values.columnName.trim())) {
                message.error('Invalid column name. Use letters, numbers, underscores, starting with a letter or underscore.');
                setConfirmLoadingAddCol(false);
                return;
            }
            if (values.columnName.length > 63) {
                 message.error('Column name is too long (max 63 characters typical).');
                 setConfirmLoadingAddCol(false);
                 return;
             }

            const payload: NewColumnPayload = {
                name: values.columnName.trim(),
                type: values.columnType,
            };
            console.log("DataGrid: ðŸ“¦ Sending Create Column Payload:", payload);
            await api.createColumn(dbId, tableName, payload);
            message.success(`Column "${payload.name}" added successfully! Refreshing schema & data...`);
            setIsAddColModalVisible(false);
            setLoadingSchema(true);
            setError(null);
            setSortConfig({ field: null, order: null });
            setFilterConfig([]); filterForm.resetFields();
            setGroupingColumn([]);
            setSearchQuery('');

             api.fetchSchema(dbId, tableName) 
                 .then(fetchedSchema => {
                     console.log("DataGrid: Schema refreshed after add column:", fetchedSchema);
                     setSchema(fetchedSchema);
                     const pk = fetchedSchema.find(col => col.isPrimaryKey);
                     setPrimaryKeyName(pk ? pk.name : null);
                     setIsPkAutoGenerated(pk ? Boolean(pk.isAutoGenerated) : false);
                     setCurrentPage(1);
                 })
                 .catch(err => {
                     console.error("DataGrid: Error during schema refresh after add column:", err);
                     setError(`Schema refresh failed after adding column: ${err.message}`);
                      setSchema([]); setPrimaryKeyName(null); setIsPkAutoGenerated(false);
                      setData([]); setTotalRows(0);
                 })
                 .finally(() => {
                      setLoadingSchema(false);
                 });

        } catch (errorInfo: any) {
            console.error('DataGrid: Add Column Failed:', errorInfo);
            const errorMsg = errorInfo?.response?.data?.error || errorInfo?.response?.data?.message || (errorInfo instanceof Error ? errorInfo.message : null) || 'Unknown error';
            if (errorInfo.errorFields) { message.error('Validation failed. Check the form.'); }
            else { message.error(`Failed to add column: ${errorMsg}`); }
        } finally {
            setConfirmLoadingAddCol(false);
        }
    };


    
    const showFilterModal = () => {
        const initialValues = { conditions: filterConfig.map((cond, index) => ({ ...cond, id: cond.id || Date.now() + index })) };
        initialValues.conditions.forEach((cond, index) => { if (cond.id === undefined) cond.id = Date.now() + index; });
        filterForm.setFieldsValue(initialValues);
        setIsFilterModalVisible(true);
    };

    const handleFilterOk = async () => {
        try {
            const values = await filterForm.validateFields();
            console.log("DataGrid: Filter form values:", values);
            const newFilterConfig: FilterCondition[] = (values.conditions || [])
                .filter((cond: any): cond is FilterCondition => !!(cond && cond.column && cond.operator))
                .map((cond: any, index: number) => {
                    const id = cond.id || Date.now() + index;
                    let finalValue = cond.value;
                    const selectedColumn = schema.find(col => col.name === cond.column);
                    const colTypeLC = selectedColumn ? selectedColumn.type.toLowerCase().split('(')[0].split(' ')[0] : '';
                    const numericTypesLC = ['numeric', 'integer', 'int', 'bigint', 'smallint', 'float', 'double', 'decimal', 'real', 'serial', 'bigserial'];
                    const booleanTypesLC = ['boolean', 'bool'];

                    if (cond.operator === 'IS NULL' || cond.operator === 'IS NOT NULL') {
                        finalValue = undefined;
                    } else if (dayjs.isDayjs(cond.value)) {
                        finalValue = cond.value.toISOString();
                    } else if (cond.value !== undefined && cond.value !== null) {
                        if (selectedColumn && numericTypesLC.includes(colTypeLC)) {
                            const num = parseFloat(String(cond.value).replace(/,/g, ''));
                            if (!isNaN(num)) {
                                finalValue = num;
                            } else {
                                console.warn(`Filter value for numeric column ${cond.column} is not a valid number: ${cond.value}`);
                                
                                finalValue = String(cond.value); 
                            }
                        } else if (selectedColumn && booleanTypesLC.includes(colTypeLC)) {
                            if (String(cond.value).toLowerCase() === 'true') {
                                finalValue = true;
                            } else if (String(cond.value).toLowerCase() === 'false') {
                                finalValue = false;
                            } else {
                                
                                console.warn(`Filter value for boolean column ${cond.column} is not 'true' or 'false': ${cond.value}`);
                                finalValue = String(cond.value); 
                            }
                        } else {
                            finalValue = String(cond.value);
                        }
                    } else if (cond.operator !== 'IS NULL' && cond.operator !== 'IS NOT NULL') {
                        console.warn(`Filter value for ${cond.column} ${cond.operator} is unexpectedly null/undefined.`);
                        finalValue = ''; 
                    }
                    return {
                        id: id,
                        column: cond.column,
                        operator: cond.operator,
                        value: finalValue,
                        logicalOperator: cond.logicalOperator || 'AND' 
                    };
                });

            console.log("DataGrid: Applying Backend Filter Config:", newFilterConfig);
            if (JSON.stringify(filterConfig) !== JSON.stringify(newFilterConfig)) {
                 setFilterConfig(newFilterConfig);
                 setCurrentPage(1);
             } else {
                 console.log("DataGrid: Filter config unchanged.");
             }
            setIsFilterModalVisible(false);
        } catch (errorInfo) {
            console.log('DataGrid: Filter validation failed:', errorInfo);
            message.error("Please fill all required filter fields correctly.");
        }
    };

    const handleFilterCancel = () => { setIsFilterModalVisible(false); };

    const handleClearFilters = () => {
        if (filterConfig.length > 0) {
            setFilterConfig([]);
            filterForm.resetFields();
            setCurrentPage(1);
        }
        setIsFilterModalVisible(false);
    };
    const handleGroupingChange = (value: string[]) => {
        if (editingKey) { message.warning('Please save or cancel edit first.'); return; }
        if (groupingColumn !== value) {
             setGroupingColumn(value);
             setCurrentPage(1);
         }
    };
    const showUploadModal = () => setIsUploadModalVisible(true);
    const handleUploadModalCancel = () => {
        if (uploading) {
            message.warning("Upload is in progress."); 
            return;
        }
        setIsUploadModalVisible(false);
    };

    const handleUploadChange: UploadProps['onChange'] = (info) => {
        const { status, name, response, error: uploadError } = info.file;
        console.log(`Upload status change for ${name}: ${status}`);

        if (status === 'uploading') {
            return;
        }
        if (status === 'done') {
            setUploading(false);
            console.log("Upload response:", response); 
            message.success(`${name} uploaded successfully. Refreshing data...`);
            handleUploadModalCancel();
            const wasAlreadyOnPage1 = currentPage === 1;
            if (!wasAlreadyOnPage1) {
                 setCurrentPage(1);
            } else {
                 setRefetchTrigger(c => c + 1);
            }

        } else if (status === 'error') {
            setUploading(false);
            
            console.error(`Upload failed (onChange): ${name}`, uploadError);
            
        }
    };


    const readFileContent = (fileToRead: RcFile): Promise<string | ArrayBuffer | null> => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
    
            reader.onload = (event) => {
                resolve(event.target?.result || null); 
            };
    
            reader.onerror = (error) => {
                console.error("FileReader error:", error);
                reject(error);
            };
            reader.readAsArrayBuffer(fileToRead);
        });
    };

    const customUploadRequest = async (options: any) => {
        const { onSuccess, onError, file, onProgress } = options;
        if (!dbId || !tableName) {
            const err = new Error("Database or Table not selected for upload");
            message.error(err.message);
            onError(err);
            return;
        }

        const formData = new FormData();
        formData.append('file', file as RcFile);

        try {
            setUploading(true);
            console.log(`DataGrid: Uploading file ${file.name} to DB ${dbId}, Table ${tableName}`);
            const response = await api.uploadData(dbId, tableName, formData, (event) => {
                if (event.lengthComputable && event.total && event.total > 0) {
                    const percent = Math.floor((event.loaded / event.total) * 100);
                    console.log(`Upload progress: ${percent}%`);
                    onProgress({ percent });
                } else {
                    onProgress({ percent: 50 }); 
                }
            });
            onSuccess(response, file); 
            message.success(`${file.name} uploaded successfully. Refreshing schema & data...`);
            handleUploadModalCancel();
            setError(null); 
            setLoadingSchema(true); 

            api.fetchSchema(dbId, tableName) 
                .then(fetchedSchema => {
                    console.log("DataGrid: Schema refreshed after upload:", fetchedSchema);
                    if (!Array.isArray(fetchedSchema)) throw new Error("Invalid schema format.");
                    setSchema(fetchedSchema); 
                    const pk = fetchedSchema.find(col => col.isPrimaryKey);
                    setPrimaryKeyName(pk ? pk.name : null);
                    setIsPkAutoGenerated(pk ? Boolean(pk.isAutoGenerated) : false);

                    
                    setCurrentPage(1);
                    
                    setSortConfig({ field: null, order: null });
                    setFilterConfig([]); filterForm.resetFields();
                    setGroupingColumn([]);
                    setSearchQuery('');
                })
                .catch(err => {
                    console.error("DataGrid: Error during schema refresh after upload:", err);
                    setError(`Schema refresh failed after upload: ${err.message}`);
                    setSchema([]); setPrimaryKeyName(null); setIsPkAutoGenerated(false);
                    setData([]); setTotalRows(0); 
                })
                .finally(() => {
                    setLoadingSchema(false); 
                    
                });

        } catch (err: any) {
            setUploading(false); 
            console.error("DataGrid: Upload failed (customRequest):", err);
            
            const errorMsg = err?.response?.data?.error 
                            || err?.response?.data?.message 
                            || err?.message 
                            || 'File upload failed';
            message.error(`Upload Failed: ${errorMsg}`, 5);
            onError(new Error(errorMsg), { message: errorMsg });

        }
    };

    const beforeUploadCheck = (file: RcFile): boolean | Promise<void> => {
         console.log("Checking file before upload:", file.name, file.type, file.size);
        const fileExtension = `.${file.name.split('.').pop()?.toLowerCase()}`;
        
        const isAcceptedType = ACCEPTED_UPLOAD_TYPES.some(accepted =>
            (accepted.startsWith('.') && fileExtension === accepted) || 
            (!accepted.startsWith('.') && file.type === accepted) 
        );

        if (!isAcceptedType) {
            message.error(`Invalid file type. Allowed types: ${ACCEPTED_UPLOAD_EXTENSIONS_STRING}. Detected: ${file.type || fileExtension}`);
            return false; 
        }

        const isLt50M = file.size / 1024 / 1024 < 50; 
        if (!isLt50M) {
            message.error('File too large! Must be smaller than 50MB.');
            return false; 
        }

        console.log("File check OK:", file.name);
        return true; 
    };

    const handleDeleteColumn = useCallback((columnName: string) => {
        if (!dbId || !tableName) return;

        
        if (columnName === primaryKeyName) {
            message.error(`Cannot delete the primary key column "${columnName}".`);
            return;
        }
         
         if (editingKey) { message.warning('Cannot delete column while editing a row.'); return; }
         if (uploading) { message.warning('Cannot delete column during upload.'); return; }


        confirm({
            title: `Delete column "${columnName}"?`,
            icon: <DeleteOutlined style={{ color: 'red' }} />,
            content: `This will permanently delete the column "${columnName}" and ALL data within it from the table "${tableName}". This action cannot be undone.`,
            okText: 'Yes, Delete Column',
            okType: 'danger',
            cancelText: 'Cancel',
            maskClosable: false,
            centered: true,
            onOk: async () => {
                const messageKey = `delete-col-${dbId}-${tableName}-${columnName}`;
                message.loading({ content: `Deleting column "${columnName}"...`, key: messageKey, duration: 0 });
                setLoadingSchema(true); 
                try {
                    console.log(`DataGrid: Attempting to delete column "${columnName}" from table "${tableName}" (DB ${dbId})`);
                    
                    await api.deleteColumn(dbId, tableName, columnName);
                    

                    message.success({ content: `Column "${columnName}" deleted successfully. Refreshing...`, key: messageKey, duration: 2 });

                    
                    setError(null);
                    api.fetchSchema(dbId, tableName) 
                        .then(fetchedSchema => {
                            console.log("DataGrid: Schema refreshed after delete column:", fetchedSchema);
                            if (!Array.isArray(fetchedSchema)) throw new Error("Invalid schema format.");
                            setSchema(fetchedSchema); 
                            const pk = fetchedSchema.find(col => col.isPrimaryKey);
                            setPrimaryKeyName(pk ? pk.name : null);
                            setIsPkAutoGenerated(pk ? Boolean(pk.isAutoGenerated) : false);
                            setCurrentPage(1); 
                            setSortConfig({ field: null, order: null });
                            setFilterConfig([]); filterForm.resetFields();
                            setGroupingColumn([]);
                            setSearchQuery('');
                        })
                        .catch(err => {
                            console.error("DataGrid: Error during schema refresh after delete column:", err);
                            setError(`Schema refresh failed after deleting column: ${err.message}`);
                            setSchema([]); setPrimaryKeyName(null); setIsPkAutoGenerated(false);
                            setData([]); setTotalRows(0);
                        })
                        .finally(() => {
                            setLoadingSchema(false);
                        });
                    

                } catch (err: any) {
                    console.error(`DataGrid: Delete Column Failed for "${columnName}":`, err);
                    const errorMsg = err?.response?.data?.error || err?.response?.data?.message || err?.message || 'Unknown error';
                    message.error({ content: `Failed to delete column "${columnName}": ${errorMsg}`, key: messageKey, duration: 5 });
                     setLoadingSchema(false); 
                } finally {
                    
                }
            },
        });
    }, [dbId, tableName, primaryKeyName, editingKey, uploading, filterForm]); 


    
    const columns = useMemo((): ColumnsType<any> => {
        if (!schema || schema.length === 0) return [];

        
        const serialNumberColumn: ColumnsType<any>[0] = {
            title: 'S.No.', key: 'frontend_sno', width: 70, fixed: 'left', align: 'center',
            render: (_, __, index) => (currentPage - 1) * pageSize + index + 1,
        };

        const displaySchema = schema.filter(col => col.name !== 'serial_num');
        const dataColumns: ColumnsType<any> = displaySchema.map((col) => {
            const editable = !(col.isPrimaryKey && isPkAutoGenerated);
            const isCurrentlyEditingRow = (recordKey: string) => recordKey === editingKey;

            
             const colTypeLC = col.type.toLowerCase().split('(')[0].split(' ')[0];
            const dateTypesLC = ['date', 'timestamp', 'datetime', 'timestamptz'];
            const booleanTypesLC = ['boolean', 'bool'];
            const numericTypesLC = ['numeric', 'integer', 'int', 'bigint', 'smallint', 'float', 'double', 'decimal', 'real', 'serial', 'bigserial'];
            const columnMenu = (
                <Menu onClick={({ domEvent }) => domEvent.stopPropagation()}>
                    {/* Add other options like Rename, Change Type later if needed */}
                    <Menu.Item
                        key="delete"
                        danger
                        icon={<DeleteOutlined />}
                        onClick={() => handleDeleteColumn(col.name)}
                    >
                        Delete Column
                    </Menu.Item>
                </Menu>
            );


            return {
                title: () => (
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                         <Tooltip title={`${col.name} (${col.type})${col.isPrimaryKey ? ' [PK]' : ''}${!col.isNullable ? ' [Required]' : ''}`}>
                             <span style={{ fontWeight: col.isPrimaryKey ? 600 : 400, flexGrow: 1, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', marginRight: '5px' }}>
                                {col.name}
                             </span>
                         </Tooltip>
                         {/* Add Dropdown trigger */}
                         <Dropdown overlay={columnMenu} trigger={['click']} placement="bottomRight">
                            <Button
                                type="text"
                                size="small"
                                icon={<DownOutlined />}
                                onClick={(e) => e.stopPropagation()} 
                                style={{ flexShrink: 0, marginLeft: '4px' }}
                                disabled={editingKey !== '' || uploading} 
                            />
                        </Dropdown>
                    </div>
                ),
                dataIndex: col.name,
                key: col.name,
                ellipsis: { showTitle: false },
                width: col.name === primaryKeyName ? 120 : 180,
                sorter: true,
                sortOrder: sortConfig.field === col.name ? sortConfig.order : null,
                align: numericTypesLC.includes(colTypeLC) ? 'right' : 'left',

                render: (text: any, record: any) => {
                    const editingThisCell = isCurrentlyEditingRow(record.key) && editable;

                    if (editingThisCell) {
                        const InputComponent = renderFormInput(col);
                        return (
                            React.cloneElement(InputComponent, {
                                value: editingRowData ? editingRowData[col.name] : undefined,
                                onChange: (eOrValue: any) => handleEditingInputChange(eOrValue, col.name),
                                onPressEnter: handleSave,
                                style: { ...InputComponent.props.style, margin: '-5px 0' },
                                autoFocus: Object.keys(editingRowData || {}).length > 1 && Object.keys(editingRowData || {})[1] === col.name 
                            })
                        );
                    } else {
                        let displayText = text;
                        if (text === null || text === undefined) {
                            return <i style={{ color: '#ccc' }}>NULL</i>;
                        }

                        if (booleanTypesLC.includes(colTypeLC)) {
                            displayText = String(text);
                        } else if (dateTypesLC.includes(colTypeLC)) {
                            try {
                                const date = dayjs(text);
                                if (date.isValid()) {
                                    const showTime = colTypeLC.includes('timestamp') || colTypeLC.includes('datetime');
                                    displayText = date.format(showTime ? 'YYYY-MM-DD HH:mm:ss' : 'YYYY-MM-DD');
                                } else {
                                     displayText = 'Invalid Date';
                                }
                            } catch { displayText = String(text); }
                        } else {
                            displayText = String(text);
                        }

                        return (
                            <Tooltip title={displayText} placement="topLeft">
                                <Text style={{ display: 'block', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                                    {displayText}
                                </Text>
                            </Tooltip>
                        );
                    }
                },
            };
        });

        const actionsColumn: ColumnsType<any>[0] | null = primaryKeyName ? {
            title: 'Actions', key: 'actions', width: 120, fixed: 'right', align: 'center',
            render: (_, record) => {
                const editing = isEditing(record);
                 const currentPkName = primaryKeyName || Object.keys(record).find(k => k !== 'key' && `row-${dbId}-${tableName}-pk-${record[k]}` === record.key);
                 const pkValue = currentPkName ? record[currentPkName] : undefined;
                const actionsDisabled = (!editing && editingKey !== '') || loadingData || uploading || pkValue === undefined || pkValue === null;
                const saveButtonLoading = loadingData && editingKey === record.key;

                return (
                    <Space size="small">
                    {editing ? (
                        <>
                            <Button type="primary" onClick={handleSave} size="small" loading={saveButtonLoading} disabled={uploading}>Save</Button>
                            <Button onClick={handleCancel} size="small" disabled={saveButtonLoading || uploading}>Cancel</Button>
                        </>
                    ) : (
                        <>
                            <Button type="link" size="small" disabled={actionsDisabled} onClick={() => handleEdit(record)}>Edit</Button>
                            <Button type="link" size="small" danger disabled={actionsDisabled} onClick={() => handleDelete(record)}>Delete</Button>
                        </>
                    )}
                </Space>
                );
            },
        } : null;

        return [ serialNumberColumn, ...dataColumns, ...(actionsColumn ? [actionsColumn] : []) ];

    }, [
        schema, primaryKeyName, isPkAutoGenerated,
        editingKey, editingRowData,
        loadingData, uploading,
        sortConfig,
        currentPage, pageSize,
        handleSave, handleCancel, handleEdit, handleDelete, handleEditingInputChange, 
        handleDeleteColumn,
        renderFormInput
    ]);


    
    if (!dbId || !tableName) {
        return <Empty description="Select a database and table from the sidebar" style={{ marginTop: 50 }} />;
    }

    
    const isLoading = loadingSchema || loadingData;
    const isEmptyTable = !isLoading && !error && schema.length === 0 && dbId && tableName; 
    const noDataFound = !isLoading && !error && schema.length > 0 && displayedData.length === 0 && data.length === 0; 
    const noSearchResults = !isLoading && !error && displayedData.length === 0 && data.length > 0 && searchQuery; 

    const getEmptyText = () => {
        if (loadingSchema) return <Spin tip="Loading schema..." />;
        if (loadingData) return <Spin tip="Loading data..." />; 
        if (error) return `Error loading data: ${error}`;
        if (isEmptyTable) return `Table "${tableName}" has no columns defined.`;
        if (noSearchResults) return `No data matching "${searchQuery}" on this page.`;
        if (noDataFound) return `No data found for table "${tableName}" with current filters.`;
         return <Empty description="No Data"/>;
    };


    return (
        <div style={{ padding: '15px', height: '100%', display: 'flex', flexDirection: 'column', background: '#fff' }}>

            {/* Header Area */}
            <div style={{ marginBottom: '10px', flexShrink: 0, display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '10px' }}>
                 <Title level={4} style={{ margin: 0, flexGrow: 1, minWidth: '200px' }}>
                 DB:{' '}
                {loadingDbName ? (
                    <Spin size="small" style={{ marginRight: '5px' }}/>
                ) : dbNameError ? (
                    <Tooltip title={dbNameError}><Text type="danger">Error</Text></Tooltip>
                ) : (
                    <Text strong>{databaseName || `ID ${dbId}`}</Text> 
                )}
                {' / Table: '}
                <Text strong>{tableName || 'Select Table'}</Text>
                     {loadingSchema && <Spin size="small" style={{ marginLeft: '10px' }} />}
                 </Title>
                    {schema.length > 0 && !loadingSchema && (
                        <Space>
                            <GroupOutlined title="Group By Columns (backend operation)" />
                            <Select
                                mode="multiple" 
                                allowClear
                                placeholder="Group By Columns" 
                                style={{ width: 250 }} 
                                value={groupingColumn} 
                                onChange={handleGroupingChange} 
                                disabled={isLoading || editingKey !== '' || uploading}
                                title="Group By Columns (backend operation)"
                                maxTagCount="responsive" 
                            >
                                {/* Options remain the same */}
                                {schema.filter(col => col.name !== 'serial_num').map(col => ( <Option key={col.name} value={col.name}>{col.name}</Option> ))}
                            </Select>
                        </Space>
                    )}
            </div>

             {/* Error Alert */}
             {error && (
                 <Alert message={error} type="error" showIcon closable onClose={() => setError(null)} style={{ marginBottom: '10px', flexShrink: 0 }} />
             )}


            {/* Toolbar Area */}
            <div style={{ marginBottom: '15px', flexShrink: 0, display: 'flex', justifyContent: 'space-between', flexWrap: 'wrap', gap: '10px' }}>
                 {/* Left Side Actions */}
                 <Space wrap>
                     <Button
                         type="primary"
                         icon={<PlusOutlined />}
                         onClick={showAddModal}
                         disabled={!primaryKeyName || isLoading || editingKey !== '' || uploading || !tableName || schema.length === 0}
                         title={!primaryKeyName ? "Cannot add row: Primary Key not identified" : "Add a new record"}
                     >
                         Add Row
                     </Button>
                     <Button
                         onClick={showAddColModal}
                         disabled={isLoading || editingKey !== '' || uploading || !tableName}
                     >
                         Add Column
                     </Button>
                     <Button
                         icon={<UploadOutlined />}
                         onClick={showUploadModal}
                         disabled={isLoading || uploading || editingKey !== '' || !tableName || schema.length === 0} 
                         loading={uploading}
                     >
                         {uploading ? 'Uploading...' : 'Upload Data'}
                     </Button>
                 </Space>
                 <Space wrap>
                     <Input.Search
                         placeholder="Search current page"
                         allowClear
                         defaultValue={searchQuery} 
                         onChange={(e) => debouncedSearch(e.target.value)} 
                         onSearch={(value) => { 
                             debouncedSearch.cancel(); 
                             setSearchQuery(value); 
                         }}
                         style={{ width: 250 }}
                         disabled={isLoading || editingKey !== '' || uploading || !tableName || schema.length === 0 || data.length === 0} 
                         enterButton={<SearchOutlined />}
                     />
                     {/* Backend Filter Button */}
                     <Tooltip title="Filter Data (backend operation)">
                         <Button
                             icon={<FilterOutlined />}
                             onClick={showFilterModal}
                             disabled={isLoading || editingKey !== '' || uploading || !tableName || schema.length === 0}
                         >
                             Filters {filterConfig.length > 0 ? `(${filterConfig.length})` : ''}
                         </Button>
                     </Tooltip>
                     {/* Backend Filter Clear Button */}
                     {filterConfig.length > 0 && (
                         <Tooltip title="Clear All Backend Filters">
                             <Button
                                 danger icon={<ClearOutlined />}
                                 onClick={handleClearFilters}
                                 disabled={isLoading || editingKey !== '' || uploading}
                             />
                         </Tooltip>
                     )}
                 </Space>
            </div>


            {/* Table Area */}
            <div style={{ flexGrow: 1, overflow: 'hidden', border: '1px solid #f0f0f0', position: 'relative' /* For Spin overlay */ }}>
                 {/* Spin covers the Table */}
                 <Spin spinning={loadingData && !error && !uploading} tip="Loading page data...">
                     <Table
                        columns={columns}
                        dataSource={displayedData} 
                        rowKey="key" 
                        pagination={false} 
                        scroll={{ x: 'max-content', y: 'calc(100vh - 350px)' }} 
                        size="small"
                        bordered
                        locale={{ emptyText: getEmptyText() }}
                        onChange={handleTableChange}
                        sticky
                    />
                 </Spin>
            </div>

            {/* Pagination Area */}
            <div style={{ marginTop: '16px', textAlign: 'right', flexShrink: 0 }}>
                 {/* Pagination driven by totalRows from backend */}
                 {totalRows > 0 && !loadingSchema && (
                     <Pagination
                         current={currentPage}
                         pageSize={pageSize}
                         total={totalRows} 
                         onChange={(page, newPageSize) => { 
                            if (editingKey) { message.warning('Please save or cancel edit first.'); return; }
                            if (uploading) { message.warning('Please wait for upload to complete.'); return; }

                            const currentPageSize = pageSize; 

                            if (newPageSize && newPageSize !== currentPageSize) {
                                console.log(`DataGrid: Page size changed from ${currentPageSize} to ${newPageSize}. Resetting to page 1.`);
                                setPageSize(newPageSize);
                                setCurrentPage(1); 
                            } else if (page !== currentPage) {
                                console.log(`DataGrid: Page changed to ${page}.`);
                                setCurrentPage(page);
                            }
                         }}
                         showSizeChanger
                         showQuickJumper
                         pageSizeOptions={['10', '20', '50', '100']}
                         showTotal={(total, range) => {
                              const start = (currentPage - 1) * pageSize + 1;
                              const end = start + displayedData.length - 1;
                              const displayedCount = displayedData.length;
                              if (total === 0) return '0 items';
                              if (displayedCount === 0 && searchQuery) return `0 of ${total} items (filtered)`;
                              if (displayedCount === 0) return `0 of ${total} items`;
                              const filterIndicator = (searchQuery || sortConfig.field) ? "(filtered/sorted)" : "";
                              return `${start}-${end} of ${total} items ${filterIndicator}`;
                          }}
                         disabled={isLoading || editingKey !== '' || uploading}
                     />
                 )}
            </div>

             {isAddModalVisible && (
                 <Modal
                     title={`Add New Row to ${tableName}`}
                     open={isAddModalVisible} 
                     onOk={handleAddOk}
                     confirmLoading={confirmLoadingAdd}
                     onCancel={handleAddCancel}
                     okText="Add Row"
                     destroyOnClose 
                     maskClosable={false} 
                     width={600}
                 >
                     <Form form={addForm} layout="vertical" name="add_row_form">
                         {schema
                             .filter(col => !(col.isPrimaryKey && isPkAutoGenerated))
                             .map(col => (
                                 <Form.Item
                                     key={`add-${col.name}`}
                                     name={col.name}
                                     label={`${col.name} (${col.type})`}
                                     rules={[{ required: !col.isNullable, message: `"${col.name}" is required` }]}
                                     tooltip={!col.isNullable ? "This field is required" : ""}
                                 >
                                     {renderFormInput(col)}
                                 </Form.Item>
                             ))}
                     </Form>
                 </Modal>
             )}

             {/* Add Column Modal */}
             {isAddColModalVisible && (
                 <Modal
                     title={`Add New Column to ${tableName}`}
                     open={isAddColModalVisible}
                     onOk={handleAddColOk}
                     confirmLoading={confirmLoadingAddCol}
                     onCancel={handleAddColCancel}
                     okText="Add Column"
                     destroyOnClose
                     maskClosable={false}
                 >
                     <Form form={addColForm} layout="vertical" name="add_column_form" initialValues={{}}>
                         <Form.Item
                             name="columnName"
                             label="Column Name"
                             rules={[
                                 { required: true, message: 'Column name is required' },
                                 { pattern: /^[a-zA-Z_][a-zA-Z0-9_]*$/, message: 'Invalid name (letters, numbers, _, starting with letter or _)'},
                                 { max: 63, message: 'Name too long (max 63 chars)' } 
                             ]}
                         >
                             <Input placeholder="e.g., email or user_status"/>
                         </Form.Item>
                         <Form.Item
                             name="columnType"
                             label="Column Type"
                             rules={[{ required: true, message: 'Column type is required' }]}
                         >
                             <Select showSearch placeholder="Select data type" optionFilterProp="children" filterOption={(input, option) => (option?.children as unknown as string).toLowerCase().includes(input.toLowerCase())}>
                                 {SUPPORTED_COLUMN_TYPES.map(type => ( <Option key={type} value={type}>{type}</Option> ))}
                             </Select>
                         </Form.Item>
                     </Form>
                 </Modal>
             )}

             {/* Filter Modal (Backend Filters) */}
             {isFilterModalVisible && (
                 <Modal
                     title="Apply Filters (Backend Operation)"
                     open={isFilterModalVisible}
                     onOk={handleFilterOk}
                     onCancel={handleFilterCancel}
                     okText="Apply Filters"
                     width={850} 
                     destroyOnClose
                     maskClosable={false}
                     footer={ 
                         <Space style={{ width: '100%', justifyContent: 'space-between' }}>
                             <Button danger onClick={handleClearFilters} disabled={filterConfig.length === 0}>Clear All Filters</Button>
                             <Space>
                                 <Button onClick={handleFilterCancel}>Cancel</Button>
                                 <Button type="primary" onClick={handleFilterOk}>Apply Filters</Button>
                             </Space>
                         </Space>}
                 >
                     <Form form={filterForm} name="filter_form" autoComplete="off" layout="vertical">
                         <Form.List name="conditions">
                         {(fields, { add, remove }) => (
                             <>
                                 {fields.map(({ key, name, ...restField }, index) => (
                                     <Space key={key} style={{ display: 'flex', marginBottom: 8, alignItems: 'baseline', flexWrap: 'nowrap' }} align="baseline">
                                         {/* Logical Operator (AND/OR) between conditions */}
                                         {index > 0 && (
                                             <Form.Item
                                                 {...restField}
                                                 name={[name, 'logicalOperator']}
                                                 initialValue="AND" 
                                                 rules={[{ required: true, message: 'AND/OR?' }]}
                                                 style={{ width: 70, flexShrink: 0 }}
                                             >
                                                 <Select>
                                                     <Option value="AND">AND</Option>
                                                     <Option value="OR">OR</Option>
                                                 </Select>
                                             </Form.Item>
                                         )}
                                         {/* Hidden field to store unique ID for React key prop stability */}
                                         <Form.Item {...restField} name={[name, 'id']} hidden noStyle initialValue={filterForm.getFieldValue(['conditions', name, 'id']) || Date.now() + index} ><Input /></Form.Item>

                                         {/* Column Selection */}
                                         <Form.Item
                                             {...restField}
                                             name={[name, 'column']}
                                             rules={[{ required: true, message: 'Select column' }]}
                                             style={{ width: 150, flexShrink: 0 }}
                                         >
                                             <Select
                                                  showSearch
                                                  placeholder="Select Column"
                                                  optionFilterProp="children"
                                                  filterOption={(input, option) => (option?.children as unknown as string).toLowerCase().includes(input.toLowerCase())}
                                                  onChange={() => { /* Reset operator/value when column changes */
                                                     const conditions = filterForm.getFieldValue('conditions');
                                                     if(conditions && conditions[index]) {
                                                         conditions[index].operator = undefined;
                                                         conditions[index].value = undefined;
                                                         filterForm.setFieldsValue({ conditions: conditions });
                                                     }
                                                 }}
                                             >
                                                 {/* Exclude complex types that are hard to filter reliably? Or allow all? */}
                                                 {schema
                                                      
                                                      .map(col => ( <Option key={col.name} value={col.name}>{col.name}</Option> ))}
                                             </Select>
                                         </Form.Item>

                                         {/* Operator Selection (depends on selected column) */}
                                         <Form.Item noStyle shouldUpdate={(prev, cur) => prev.conditions?.[index]?.column !== cur.conditions?.[index]?.column }>
                                             {({ getFieldValue }) => {
                                                 const colName = getFieldValue(['conditions', index, 'column']);
                                                 const selCol = schema.find(c=>c.name===colName);
                                                 
                                                 const colTypeBase = selCol?.type.toLowerCase().split('(')[0].split(' ')[0];
                                                 const numericTypesLC = ['numeric', 'integer', 'int', 'bigint', 'smallint', 'float', 'double', 'decimal', 'real', 'serial', 'bigserial'];
                                                 const dateTypesLC = ['date', 'timestamp', 'datetime', 'timestamptz'];
                                                 const booleanTypesLC = ['boolean', 'bool'];

                                                 let applicableOperators = [...FILTER_OPERATORS];
                                                 if (selCol) {
                                                     if (numericTypesLC.includes(colTypeBase || '') || dateTypesLC.includes(colTypeBase || '')) {
                                                         
                                                         applicableOperators = applicableOperators.filter(op => op.value !== 'LIKE' && op.value !== 'NOT LIKE');
                                                     }
                                                     if (booleanTypesLC.includes(colTypeBase || '')) {
                                                         
                                                         applicableOperators = applicableOperators.filter(op => ['=', '!=', 'IS NULL', 'IS NOT NULL'].includes(op.value));
                                                     }
                                                     
                                                 }


                                                 return (
                                                     <Form.Item
                                                         {...restField}
                                                         name={[name, 'operator']}
                                                         rules={[{ required: true, message: 'Select operator' }]}
                                                          style={{ width: 180, flexShrink: 0 }}
                                                     >
                                                         <Select
                                                             placeholder="Operator"
                                                             disabled={!colName} 
                                                             onChange={() => { /* Reset value when operator changes */
                                                                 const conditions = filterForm.getFieldValue('conditions');
                                                                 if(conditions && conditions[index]) {
                                                                     conditions[index].value = undefined;
                                                                     filterForm.setFieldsValue({ conditions: conditions });
                                                                 }
                                                             }}
                                                         >
                                                             {applicableOperators.map(op => ( <Option key={op.value} value={op.value}>{op.label}</Option> ))}
                                                         </Select>
                                                     </Form.Item>
                                                 );
                                             }}
                                         </Form.Item>

                                         {/* Value Input (depends on selected column and operator) */}
                                         <Form.Item noStyle shouldUpdate={(prev, cur) =>
                                             prev.conditions?.[index]?.column !== cur.conditions?.[index]?.column ||
                                             prev.conditions?.[index]?.operator !== cur.conditions?.[index]?.operator
                                         }>
                                             {({ getFieldValue }) => {
                                                 const operator = getFieldValue(['conditions', index, 'operator']);
                                                 const needsValue = operator && !['IS NULL', 'IS NOT NULL'].includes(operator);
                                                 return (
                                                     <Form.Item
                                                         {...restField}
                                                         name={[name, 'value']}
                                                         rules={[{ required: needsValue, message: 'Value required' }]}
                                                          style={{ minWidth: 200, flexGrow: 1 }} 
                                                     >
                                                         {/* Render input based on column type, disable if no value needed */}
                                                         {needsValue ? renderFilterValueInput(index) : <Input disabled placeholder="No value needed" style={{ width: 200 }}/>}
                                                     </Form.Item>
                                                 );
                                             }}
                                         </Form.Item>

                                         {/* Remove Button */}
                                         <DeleteOutlined
                                             onClick={() => remove(name)}
                                             style={{ color: 'red', cursor: 'pointer', fontSize: '16px', marginLeft: '8px' }}
                                             title="Remove this filter condition"
                                         />
                                     </Space>
                                 ))}

                                 {/* Add Filter Button */}
                                 <Form.Item style={{ marginTop: '10px' }}>
                                     <Button type="dashed" onClick={() => add({ id: Date.now(), logicalOperator: 'AND' })} block icon={<PlusOutlined />}>
                                         Add Filter Condition
                                     </Button>
                                 </Form.Item>
                             </>
                         )}
                         </Form.List>
                     </Form>
                 </Modal>
             )}

             {/* Upload Data Modal */}
             <Modal
                title={`Upload Data to ${tableName}`}
                open={isUploadModalVisible} 
                onCancel={handleUploadModalCancel}
                footer={null}
                destroyOnClose
                maskClosable={false}
             >
                 <Spin spinning={uploading} tip="Processing upload...">
                     <Dragger
                         name="file"
                         multiple={false}
                         accept={ACCEPTED_UPLOAD_TYPES.join(',')}
                         customRequest={customUploadRequest}
                         onChange={handleUploadChange}
                         beforeUpload={beforeUploadCheck}
                         disabled={uploading || !tableName || isLoading}
                         style={{ padding: '20px' }}
                         height={200} 
                     >
                         <p className="ant-upload-drag-icon">
                             <InboxOutlined />
                         </p>
                         <p className="ant-upload-text">Click or drag file to this area to upload</p>
                         <p className="ant-upload-hint">
                             Supports single file upload. Allowed types: {ACCEPTED_UPLOAD_EXTENSIONS_STRING}. Max size: 50MB. Ensure column headers in the file match table columns.
                         </p>
                     </Dragger>
                 </Spin>
             </Modal>

        </div> 
    );
};

export default DataGrid;